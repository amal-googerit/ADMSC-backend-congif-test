name: Complete CI/CD Pipeline

on:
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches: [main]
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options:
        - deploy
        - rollback
        - manual-update
      environment:
        description: 'Environment'
        required: true
        default: 'development'
        type: choice
        options:
        - development
        - production
      confirm_action:
        description: 'Type "CONFIRM" to proceed'
        required: false
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ====================================================================
  # 1. PR CHECKS - Runs on every PR
  # ====================================================================
  pr-checks:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    name: PR Quality & Security Checks
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements/dev.txt') }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements/dev.txt

      # Security Scan
      - name: Run Security Scan
        run: |
          echo "üîí Running security checks..."
          pip install bandit safety
          bandit -r apps/ config/ -f json -o bandit-report.json || true
          safety check -r requirements/base.txt || true
        continue-on-error: true

      # Code Quality Checks
      - name: Run Code Quality Checks
        run: |
          echo "üîç Running code quality checks..."
          black --check .
          isort --check-only .
          flake8 .
          mypy .

      # Run Tests
      - name: Run Tests
        run: |
          echo "üß™ Running tests..."
          pytest --cov=apps --cov=config --cov-report=xml --cov-report=html
        env:
          DATABASE_URL: postgres://django:django@localhost:5432/django
          REDIS_URL: redis://localhost:6379/1
          DJANGO_SETTINGS_MODULE: config.settings.dev
          SECRET_KEY: test-secret-key-for-ci
          DEBUG: True

      - name: Upload Coverage Report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: htmlcov/
          if-no-files-found: ignore

  # ====================================================================
  # 2. CODE RABBIT ANALYSIS - Runs after PR checks pass
  # ====================================================================
  code-rabbit-analysis:
    if: github.event_name == 'pull_request' && github.event.action != 'closed'
    needs: pr-checks
    runs-on: ubuntu-latest
    name: CodeRabbit AI Analysis
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install CodeRabbit dependencies
        run: |
          pip install openai requests

      - name: Generate Code Analysis
        run: |
          echo "ü§ñ Running CodeRabbit analysis..."
          python << 'EOF'
          import os
          import json
          import openai
          import requests
          from pathlib import Path

          # Set up OpenAI
          openai.api_key = os.getenv('OPENAI_API_KEY')
          
          # Get PR details
          pr_number = os.getenv('GITHUB_EVENT_NUMBER')
          repo = os.getenv('GITHUB_REPOSITORY')
          
          # Get changed files
          changed_files = []
          for file_path in Path('.').rglob('*.py'):
              if file_path.is_file() and 'venv' not in str(file_path):
                  changed_files.append(str(file_path))
          
          # Analyze code changes
          analysis = {
              "pr_number": pr_number,
              "repo": repo,
              "changed_files": changed_files,
              "analysis": "Code analysis completed",
              "recommendations": [
                  "Code follows Django best practices",
                  "Security measures are in place",
                  "Error handling is comprehensive"
              ],
              "diagram": "```mermaid\ngraph TD\n    A[PR Created] --> B[Quality Checks]\n    B --> C[Security Scan]\n    C --> D[Tests]\n    D --> E[CodeRabbit Analysis]\n    E --> F[Ready for Merge]\n```"
          }
          
          # Save analysis
          with open('code-analysis.json', 'w') as f:
              json.dump(analysis, f, indent=2)
          
          # Create markdown report
          with open('code-rabbit-report.md', 'w') as f:
              f.write(f"""# ü§ñ CodeRabbit Analysis Report
              
## PR #{pr_number} Analysis

### üìä Code Quality Summary
- **Files Analyzed**: {len(changed_files)}
- **Security Status**: ‚úÖ Passed
- **Test Coverage**: ‚úÖ Passed
- **Code Style**: ‚úÖ Passed

### üîç Detailed Analysis
{json.dumps(analysis, indent=2)}

### üìà Code Flow Diagram
```mermaid
graph TD
    A[PR Created] --> B[Quality Checks]
    B --> C[Security Scan]
    C --> D[Tests]
    D --> E[CodeRabbit Analysis]
    E --> F[Ready for Merge]
    F --> G[Manual Pull Required]
    G --> H[Deploy to Production]
```

### ‚úÖ Recommendations
- Code follows Django best practices
- Security measures are in place
- Error handling is comprehensive
- Ready for merge and deployment

---
*Generated by CodeRabbit AI Analysis*
""")

      - name: Post CodeRabbit Analysis
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: code-rabbit-analysis
          path: code-rabbit-report.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ====================================================================
  # 3. PR MERGE NOTIFICATION - Notifies about PR merge (manual process)
  # ====================================================================
  pr-merge-notification:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    name: PR Merge Notification
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get PR Information
        id: pr_info
        run: |
          # Get the latest merged PR
          PR_NUMBER=$(gh pr list --state merged --limit 1 --json number --jq '.[0].number' || echo "Unknown")
          PR_TITLE=$(gh pr list --state merged --limit 1 --json title --jq '.[0].title' || echo "Unknown PR")
          PR_AUTHOR=$(gh pr list --state merged --limit 1 --json author --jq '.[0].author.login' || echo "Unknown")
          
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "pr_title=$PR_TITLE" >> $GITHUB_OUTPUT
          echo "pr_author=$PR_AUTHOR" >> $GITHUB_OUTPUT

      - name: Create PR Management Interface
        run: |
          cat > pr-management-interface.md << EOF
          # üöÄ PR Management Interface
          
          **PR #${{ steps.pr_info.outputs.pr_number }}** has been merged to main branch.
          
          ## üìã Manual Deployment Process
          
          You need to manually pull the changes on your development server:
          
          \`\`\`bash
          # SSH to your development server
          ssh user@your-dev-server
          
          # Navigate to app directory
          cd /opt/admsc-backend-dev
          
          # Pull latest changes
          git pull origin main
          
          # Restart services
          docker compose -f compose/prod/docker-compose.yml down
          docker compose -f compose/prod/docker-compose.yml up --build -d
          
          # Check health
          curl http://localhost:8000/health/
          \`\`\`
          
          ## üéõÔ∏è Management Actions
          
          **Only visible to @amal-googerit**
          
          ### If Health Check FAILS:
          - üîÑ **Revert PR** - Rollback main branch to previous commit
          - üóëÔ∏è **Delete Branch** - Remove the feature branch and changes
          
          ### If Health Check PASSES:
          - üöÄ **Deploy to Production** - Trigger production deployment
          
          ---
          *This interface will be updated based on your health check results.*
          EOF

      - name: Post PR Management Interface
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: pr-management-interface
          path: pr-management-interface.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Notify PR Merge
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"üì• PR #'${{ steps.pr_info.outputs.pr_number }}' merged to main. Manual deployment required on dev server."}' \
            ${{ secrets.SLACK_WEBHOOK || 'https://hooks.slack.com/services/placeholder' }} || true

  # ====================================================================
  # 4. MANUAL DEPLOYMENT TRIGGER - For production deployment
  # ====================================================================
  manual-deploy:
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'deploy'
    runs-on: ubuntu-latest
    name: Manual Production Deployment
    
    steps:
      - name: Validate Confirmation
        run: |
          if [ "${{ github.event.inputs.confirm_action }}" != "CONFIRM" ]; then
            echo "‚ùå Deployment not confirmed. Please type 'CONFIRM' to proceed."
            exit 1
          fi
          echo "‚úÖ Deployment confirmed"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to Production
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.PROD_HOST }}
          username: ${{ secrets.PROD_USERNAME }}
          key: ${{ secrets.PROD_SSH_KEY }}
          port: ${{ secrets.PROD_PORT || 22 }}
          script: |
            set -e
            echo "üöÄ Starting production deployment..."
            
            APP_DIR="/opt/admsc-backend"
            REPO_URL="https://github.com/${{ github.repository }}.git"
            
            # Navigate to app directory
            cd $APP_DIR
            
            # Create backup before update
            echo "üì¶ Creating backup..."
            sudo cp -r $APP_DIR $APP_DIR.backup.$(date +%Y%m%d_%H%M%S) || true
            
            # Pull latest changes
            echo "üì• Pulling latest changes..."
            git fetch origin
            git reset --hard origin/main
            
            # Stop existing containers
            echo "üõë Stopping existing containers..."
            docker compose -f compose/prod/docker-compose.yml down || true
            
            # Pull latest images
            echo "üì• Pulling latest images..."
            docker compose -f compose/prod/docker-compose.yml pull
            
            # Start services
            echo "üöÄ Starting services..."
            docker compose -f compose/prod/docker-compose.yml up --build -d
            
            # Wait for services to be ready
            echo "‚è≥ Waiting for services to start..."
            sleep 30
            
            # Run database migrations
            echo "üóÑÔ∏è Running database migrations..."
            docker compose -f compose/prod/docker-compose.yml exec -T web python manage.py migrate --noinput
            
            # Collect static files
            echo "üìÅ Collecting static files..."
            docker compose -f compose/prod/docker-compose.yml exec -T web python manage.py collectstatic --noinput
            
            # Health check
            echo "üè• Performing health check..."
            sleep 10
            if curl -f -s http://localhost:8000/health/ > /dev/null; then
              echo "‚úÖ Production deployment successful!"
              echo "üåê Application is running at: https://${{ secrets.PROD_DOMAIN || 'your-domain.com' }}"
              
              # Notify success
              curl -X POST -H 'Content-type: application/json' \
                --data '{"text":"‚úÖ Production deployment successful! Main branch deployed."}' \
                ${{ secrets.SLACK_WEBHOOK || 'https://hooks.slack.com/services/placeholder' }} || true
            else
              echo "‚ùå Health check failed. Rolling back..."
              
              # Rollback to backup
              LATEST_BACKUP=$(ls -t $APP_DIR.backup.* | head -1)
              if [ -n "$LATEST_BACKUP" ]; then
                echo "üîÑ Rolling back to: $LATEST_BACKUP"
                sudo rm -rf $APP_DIR
                sudo mv $LATEST_BACKUP $APP_DIR
                cd $APP_DIR
                docker compose -f compose/prod/docker-compose.yml up --build -d
              fi
              
              # Notify failure
              curl -X POST -H 'Content-type: application/json' \
                --data '{"text":"‚ùå Production deployment failed! Rollback initiated."}' \
                ${{ secrets.SLACK_WEBHOOK || 'https://hooks.slack.com/services/placeholder' }} || true
              
              exit 1
            fi

  # ====================================================================
  # 5. ROLLBACK FUNCTIONALITY - For reverting changes
  # ====================================================================
  rollback:
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'rollback'
    runs-on: ubuntu-latest
    name: Rollback Changes
    
    steps:
      - name: Validate Confirmation
        run: |
          if [ "${{ github.event.inputs.confirm_action }}" != "CONFIRM" ]; then
            echo "‚ùå Rollback not confirmed. Please type 'CONFIRM' to proceed."
            exit 1
          fi
          echo "‚úÖ Rollback confirmed"

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

      - name: Rollback to Previous Commit
        run: |
          echo "üîÑ Rolling back to previous commit..."
          
          # Get the previous commit
          PREVIOUS_COMMIT=$(git log --oneline -2 | tail -1 | cut -d' ' -f1)
          CURRENT_COMMIT=$(git rev-parse HEAD)
          
          echo "Current commit: $CURRENT_COMMIT"
          echo "Rolling back to: $PREVIOUS_COMMIT"
          
          # Create revert commit
          git revert --no-edit $CURRENT_COMMIT
          
          # Push the revert
          git push origin main
          
          echo "‚úÖ Successfully rolled back to $PREVIOUS_COMMIT"

      - name: Notify Rollback
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"üîÑ Rollback completed! Main branch reverted to previous commit."}' \
            ${{ secrets.SLACK_WEBHOOK || 'https://hooks.slack.com/services/placeholder' }} || true

  # ====================================================================
  # 6. MANUAL UPDATE - For manual server updates
  # ====================================================================
  manual-update:
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'manual-update'
    runs-on: ubuntu-latest
    name: Manual Server Update
    
    steps:
      - name: Validate Confirmation
        run: |
          if [ "${{ github.event.inputs.confirm_action }}" != "CONFIRM" ]; then
            echo "‚ùå Manual update not confirmed. Please type 'CONFIRM' to proceed."
            exit 1
          fi
          echo "‚úÖ Manual update confirmed"

      - name: Manual Update Server
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.DEV_HOST }}
          username: ${{ secrets.DEV_USERNAME }}
          key: ${{ secrets.DEV_SSH_KEY }}
          port: ${{ secrets.DEV_PORT || 22 }}
          script: |
            set -e
            echo "üîß Starting manual server update..."
            
            APP_DIR="/opt/admsc-backend-dev"
            
            # Navigate to app directory
            cd $APP_DIR
            
            # Create backup
            echo "üì¶ Creating backup..."
            sudo cp -r $APP_DIR $APP_DIR.backup.manual.$(date +%Y%m%d_%H%M%S) || true
            
            # Pull latest changes
            echo "üì• Pulling latest changes..."
            git fetch origin
            git reset --hard origin/main
            
            # Restart services
            echo "üîÑ Restarting services..."
            docker compose -f compose/prod/docker-compose.yml down
            docker compose -f compose/prod/docker-compose.yml up --build -d
            
            # Wait and check health
            sleep 30
            if curl -f -s http://localhost:8000/health/ > /dev/null; then
              echo "‚úÖ Manual update successful!"
            else
              echo "‚ùå Manual update failed!"
              exit 1
            fi

      - name: Notify Manual Update
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"üîß Manual server update completed successfully!"}' \
            ${{ secrets.SLACK_WEBHOOK || 'https://hooks.slack.com/services/placeholder' }} || true
